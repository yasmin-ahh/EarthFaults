# -*- coding: utf-8 -*-
"""
Created on Tue Dec  3 19:23:42 2024

@author: PSP19
"""

import numpy as np
import matplotlib.pyplot as plt

# File paths (replace with your actual file paths)
cfg_file = r"D:\Study Material\Project\Data\Fault RESPE 4.cfg"
dat_file = r"D:\Study Material\Project\Data\Fault RESPE 4.dat"

# Step 1: Parse the .cfg file
cfg_metadata = {}
analog_channel_labels = []
digital_channel_labels = []

with open(cfg_file, "r") as cfg:
    lines = cfg.readlines()

    # Extract metadata
    cfg_metadata['station_name'], cfg_metadata['rec_dev_id'], cfg_metadata['rev_year'] = lines[0].strip().split(",")
    second_line = lines[1].strip().split(",")
    analog_count = int(''.join(filter(str.isdigit, second_line[1])))
    digital_count = int(''.join(filter(str.isdigit, second_line[2])))

    # Extract analog channel labels
    for i in range(2, 2 + analog_count):
        parts = lines[i].strip().split(",")
        analog_channel_labels.append(parts[1])  # Channel name

# Step 2: Parse the .dat file
timestamps = []
analog_samples = []
digital_samples = []

with open(dat_file, "r") as dat:
    for line in dat:
        parts = line.strip().split(",")
        if len(parts) >= 2 + analog_count + digital_count:
            try:
                timestamps.append(float(parts[1]))
                analog_samples.append([float(x) for x in parts[2:2 + analog_count]])
                digital_samples.append([int(x) for x in parts[2 + analog_count:]])
            except ValueError:
                pass

# Convert lists to numpy arrays
timestamps = np.array(timestamps)
analog_samples = np.array(analog_samples)
digital_samples = np.array(digital_samples)

# Step 3: Plot Voltage and Current Graphs
# Assuming first three analog channels are voltages (Ua, Ub, Uc)
# and next three analog channels are currents (Ia, Ib, Ic)
plt.figure(figsize=(15, 10))

# Voltage plot
plt.subplot(2, 1, 1)
for i, label in enumerate(analog_channel_labels[:3]):  # First 3 are voltage channels
    plt.plot(timestamps, analog_samples[:, i], label=label)
plt.title("Voltage Signals")
plt.xlabel("Time (s)")
plt.ylabel("Voltage (V)")
plt.legend()
plt.grid()

# Current plot
plt.subplot(2, 1, 2)
for i, label in enumerate(analog_channel_labels[3:6]):  # Next 3 are current channels
    plt.plot(timestamps, analog_samples[:, i + 3], label=label)  # Offset by 3
plt.title("Current Signals")
plt.xlabel("Time (s)")
plt.ylabel("Current (A)")
plt.legend()
plt.grid()

# Show the plots
plt.tight_layout()
plt.show()

# Fault Detection Logic
def detect_fault(U0, I0, threshold):
    """
    Detect faults based on zero-sequence components and active power.
    Args:
        U0 (float): Zero-sequence voltage.
        I0 (float): Zero-sequence current.
        threshold (float): Fault threshold.
    Returns:
        str: Fault detection result.
    """
    phase_angle = np.angle(U0)
    cos_phi = np.cos(phase_angle)
    W = U0 * I0 * cos_phi  # Active power

    if W > threshold:
        return -1   #Reverse Fault Detected
    elif W < -threshold:
        return 1    #Fault is detected
    else:
        return 0    #Fault is not detected

# detect fault
for i in range(len(analog_samples)):  # First 3 are voltage channels
    
    # Zero-sequence computation
    U0 = (analog_samples[i,0]+ analog_samples[i,1]+analog_samples[i,2])/3000 # First 3 columns are Ua, Ub, Uc
    I0 = (analog_samples[i,4]+ analog_samples[i,5]+analog_samples[i,6])/3000  # Next 3 columns are Ia, Ib, Ic
    print("V0=",U0)
    print("I0=",I0)
    #Get fourier Transform
    #fourier_transform()
    result = detect_fault(U0,I0,10)
    if(1==result):
        print("Forward fault detected at",timestamps[i])
        break
    elif(-1 == result):
        print("Reverse fault detected at",timestamps[i])
        break
    else:
        print("No fault detected")
