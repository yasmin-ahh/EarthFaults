# -*- coding: utf-8 -*-
"""
Created on Tue Dec  3 19:23:42 2024

@author: PSP19
"""

import os
import numpy as np
import matplotlib.pyplot as plt
from utilities.signal_processing import high_pass_filter
from utilities.fault_classification import detect_fault_with_thresholds, classify_fault
from utilities.threshold_compute import compute_thresholds
import pyComtrade


def process_comtrade_data(folder_path):
    """
    Processes Comtrade files in a folder and identifies faults based on U0 and I0 thresholds.

    Parameters:
    - folder_path: Path to the folder containing Comtrade files (.cfg and .dat).
    - cutoff_freq: High-pass filter cutoff frequency (default: 50 Hz).
    """
    files = [f for f in os.listdir(folder_path) if f.endswith('.cfg')]
    for cfg_file in files:
        dat_file = cfg_file.replace('.cfg', '.dat')

        if not os.path.exists(os.path.join(folder_path, dat_file)):
            print(f"Dat file not found for {cfg_file}. Skipping.")
            continue

        # Load the Comtrade data
        comtradeObj = pyComtrade.ComtradeRecord()
        comtradeObj.read(os.path.join(folder_path, cfg_file), os.path.join(folder_path, dat_file))
        
        # Extract time, voltage, and current data
        timestamps = comtradeObj.get_timestamps()

        # Extract raw voltages, zero-sequence current, and currents
        raw_voltages = [ch['values'] for ch in comtradeObj.cfg_data['A'][0:3]]  # Channels 1, 2, 3
        raw_zero_seq_current = comtradeObj.cfg_data['A'][3]['values']  # Channel 4
        # raw_currents = [ch['values'] for ch in comtradeObj.cfg_data['A'][4:7]]  # Channels 5, 6, 7

        # Ensure dimensions match timestamps
        min_length = len(timestamps)
        voltages = [v[:min_length] for v in raw_voltages]
        currents2 = [c[:min_length] for c in currents]
        if raw_zero_seq_current is not None:
            zero_seq_current = raw_zero_seq_current[:min_length]
      
        return voltages,currents2,zero_seq_current

"""            
#get input  data from Comtrade files
def getInputData():
    # File paths (replace with your actual file paths)
    cfg_file = r"D:\Study Material\Project\Data\rspe4.cfg"
    dat_file = r"D:\Study Material\Project\Data\rspe4.dat"
    
    # Step 1: Parse the .cfg file
    cfg_metadata = {}
    analog_channel_labels = []
    digital_channel_labels = []
    
    with open(cfg_file, "r") as cfg:
        lines = cfg.readlines()
    
        # Extract metadata
        cfg_metadata['station_name'], cfg_metadata['rec_dev_id'], cfg_metadata['rev_year'] = lines[0].strip().split(",")
        second_line = lines[1].strip().split(",")
        analog_count = int(''.join(filter(str.isdigit, second_line[1])))
        digital_count = int(''.join(filter(str.isdigit, second_line[2])))
    
        # Extract analog channel labels
        for i in range(2, 2 + analog_count):
            parts = lines[i].strip().split(",")
            analog_channel_labels.append(parts[1])  # Channel name
    
    # Step 2: Parse the .dat file
    timestamps = []
    analog_samples = []
    digital_samples = []
    
    with open(dat_file, "r") as dat:
        for line in dat:
            parts = line.strip().split(",")
            if len(parts) >= 2 + analog_count + digital_count:
                try:
                    timestamps.append(float(parts[1]))
                    analog_samples.append([float(x) for x in parts[2:2 + analog_count]])
                    digital_samples.append([int(x) for x in parts[2 + analog_count:]])
                except ValueError:
                    pass
    
    # Convert lists to numpy arrays
    timestamps = np.array(timestamps)
    analog_samples = np.array(analog_samples)
    digital_samples = np.array(digital_samples)
    
    # Split voltage and current signals
    voltages = analog_samples[:, :3]  # Columns for Ua, Ub, Uc
    currents = analog_samples[:, 4:7]  # Columns for Ia, Ib, Ic
    
    return voltages, currents,timestamps
"""
# Compute Zero-Sequence Components
def compute_zero_sequence(voltages, currents):
    """
    Compute zero-sequence voltage and current components.
    Args:
        voltages (array): Voltage samples [Ua, Ub, Uc].
        currents (array): Current samples [Ia, Ib, Ic].
    Returns:
        tuple: Zero-sequence voltage (U0) and current (I0).
    """
    U0 = np.mean(voltages, axis=1)  # Zero-sequence voltage
    I0 = np.mean(currents, axis=1)  # Zero-sequence current
    return U0, I0

#Fourier Transform Filter
def extract_5th_harmonic(voltage, current, sampling_rate, fundamental_frequency):
    """
    Extract the 5th harmonic from voltage and current arrays.
    
    Parameters:
        voltage (np.ndarray): 3xN array of voltage signals.
        current (np.ndarray): 3xN array of current signals.
        sampling_rate (float): Sampling rate of the signals in Hz.
        fundamental_frequency (float): Fundamental frequency in Hz.
    
    Returns:
        tuple: Filtered voltage and current signals (3xN arrays) containing only the 5th harmonic.
    """
    
    # Compute FFT for both voltage and current
    voltage_fft = np.fft.fft(voltage, axis=1)
    current_fft = np.fft.fft(current, axis=1)
    
    # Frequency resolution
    N = voltage.shape[1]
    freq_resolution = sampling_rate / N
    fifth_harmonic_freq = 5 * fundamental_frequency
    
    # Find the index of the 5th harmonic
    harmonic_index = int(round(fifth_harmonic_freq / freq_resolution))
    
    # Create a mask for the 5th harmonic
    harmonic_mask = np.zeros(N, dtype=complex)
    harmonic_mask[harmonic_index] = 1  # Positive frequency
    harmonic_mask[-harmonic_index] = 1  # Negative frequency (complex conjugate)
    
    # Apply the mask to isolate the 5th harmonic
    filtered_voltage_fft = voltage_fft * harmonic_mask
    filtered_current_fft = current_fft * harmonic_mask
    
    # Inverse FFT to return to the time domain
    filtered_voltage = np.fft.ifft(filtered_voltage_fft, axis=1).real
    filtered_current = np.fft.ifft(filtered_current_fft, axis=1).real
    
    return filtered_voltage, filtered_current

# Fault Detection Logic
def detect_fault(U0, I0, threshold):
    """
    Detect faults based on zero-sequence components and active power.
    Args:
        U0 (float): Zero-sequence voltage.
        I0 (float): Zero-sequence current.
        threshold (float): Fault threshold.
    Returns:
        str: Fault detection result.
    """
    phase_angle = np.angle(U0) - np.angle(I0)  # Phase angle of zero-sequence components
    sin_phi = np.sin(phase_angle)
    W = U0 * I0 * sin_phi  # Reactive power
    fault_time = None
    
    # Check for the first instance where rective power crosses the threshold
    for i, power in enumerate(W):
        if power > threshold:
            results = "Forward Fault Detected"
            fault_time = timestamps[i]
            break
        elif power < -threshold:
            results = "Reverse Fault Detected"
            fault_time = timestamps[i]
            break
    print("\nReactive Power : ", np.mean(W))
    print(f"Fault Time: {fault_time if fault_time else 'No Fault Detected'} ")
    print("Fault type : ", results)
    return results, fault_time

# Calculating Threshold from Fault-free data
def compute_threshold(U0, I0, fault_free_start, fault_free_end, timestamps, n=3):
    """
    Compute threshold for fault detection based on fault-free data.

    Args:
        U0 (array): Zero-sequence voltage array.
        I0 (array): Zero-sequence current array.
        fault_free_start (float): Start time of fault-free region (seconds).
        fault_free_end (float): End time of fault-free region (seconds).
        timestamps (array): Array of timestamps corresponding to U0 and I0.
        n (int): Sensitivity multiplier for threshold calculation.

    Returns:
        float: Calculated threshold.
    """
    # Identify fault-free data indices based on the given time range
    fault_free_indices = (timestamps >= fault_free_start) & (timestamps <= fault_free_end)

    # Extract fault-free data
    fault_free_U0 = U0[fault_free_indices]
    fault_free_I0 = I0[fault_free_indices]

    # Compute reactive power (W) in fault-free region
    phase_angle = np.angle(fault_free_U0) - np.angle(fault_free_I0)
    sin_phi = np.sin(phase_angle)
    fault_free_W = fault_free_U0 * fault_free_I0 * sin_phi

    # Compute mean and standard deviation of reactive power
    mean_W = np.mean(fault_free_W)
    std_W = np.std(fault_free_W)

    # Calculate threshold using mean + n * std deviation
    threshold = mean_W + n * std_W
    print(f"Computed Threshold: {threshold}")

    return threshold

# Path to the folder containing Comtrade files
folder_path = "comdata"
voltages,currents,timestamps = process_comtrade_data(folder_path)

freq =50
sampling_rate = 10000
#Get 5th harmonics
fifth_Harmonic_V, fifth_Harmonic_I = extract_5th_harmonic(voltages, currents, sampling_rate, freq)
# Compute zero-sequence components
fifth_Harmonic_V0, fifth_Harmonic_I0 = compute_zero_sequence(fifth_Harmonic_V,fifth_Harmonic_I)

# Compute threshold
# Define fault-free time range (e.g., 0 to 2 seconds)
fault_free_start = 0  # Start time in seconds
fault_free_end = 1000  # End time in seconds
THRESHOLD = compute_threshold(fifth_Harmonic_V0, fifth_Harmonic_I0, fault_free_start, fault_free_end, timestamps, n=3)

# Detect faults
fault_results = detect_fault(fifth_Harmonic_V0, fifth_Harmonic_I0, THRESHOLD)

# Plotting the voltages and currents
plt.figure(figsize=(20, 20))
   
# Subplot for voltages
plt.subplot(4, 1, 1)
plt.plot(timestamps, voltages[:, 0], label='Ua', color='blue')
plt.plot(timestamps, voltages[:, 1], label='Ub', color='red')
plt.plot(timestamps, voltages[:, 2], label='Uc', color='green')
plt.title("Three-Phase Voltages")
plt.xlabel("Time (s)")
plt.ylabel("Voltage (V)")
plt.legend()
plt.grid()

# Subplot for currents
plt.subplot(4, 1, 2)
plt.plot(timestamps, currents[:, 0], label='Ia', color='red')
plt.plot(timestamps, currents[:, 1], label='Ib', color='blue')
plt.plot(timestamps, currents[:, 2], label='Ic', color='green')
plt.title("Three-Phase Currents")
plt.xlabel("Time (s)")
plt.ylabel("Current (A)")
plt.legend()
plt.grid()

# Subplot for zero-sequence voltage
plt.subplot(4, 1, 3)
plt.plot(timestamps, fifth_Harmonic_V0, label='Zero-sequence Voltage (U0)', color='blue')
plt.title("Zero-Sequence Voltage (U0)")
plt.xlabel("Time (s)")
plt.ylabel("Voltage (V)")
plt.legend()
plt.grid()

# Subplot for zero-sequence current
plt.subplot(4, 1, 4)
plt.plot(timestamps, fifth_Harmonic_I0, label='Zero-sequence Current (I0)', color='red')
plt.title("Zero-Sequence Current (I0)")
plt.xlabel("Time (s)")
plt.ylabel("Current (A)")
plt.legend()
plt.grid()
# Adjust spacing
plt.tight_layout()

# Show the plot
plt.show()
